function [ newSS ] = mySegmenter( oldStrucStats, I )
%INPUT
%{
    Single image structure with all objects found with bwconncomp
    Grayscale image (int8 or double)
%}
%OUTPUT
%{
    Refined segmentation of objects
    Updated structure list of objects
%}


%enter structure stats generated by region props, include original image in 
%   Detailed explanation goes here

    wsI = I; %uint8 or double intensity image

    %Iterate through all objects and perform refined segmentation for "clumped
    %objects". Will need to establish criteria for expected clumped cells. And
    %will need to modify register to reflect clumped object as a segmented
    %object.
    hwait = waitbar(0,'Progress...');

    for j = 1:length(oldStrucStats)
        wsBox = floor(oldStrucStats(j).BoundingBox); %boundingbox gives [column row columnWidth rowWidth]
        wsInd = oldStrucStats(j).PixelIdxList;
        wsItemp = (zeros(size(wsI),'uint8'));
        wsItemp(wsInd) = wsI(wsInd);
%         colBox = wsBox(1):wsBox(1)+wsBox(3);
%         rowBox = wsBox(2):wsBox(2)+wsBox(4);
%         wsIsub = wsItemp(rowBox,colBox); %changed 5/21/17
        wsIsub = imcrop(wsItemp,wsBox);
    %     figure,imshow(wsIsub)
        bw = logical(wsIsub); %updated 07-06-17
    %     figure,imshow(bw)

%         hy = fspecial('sobel');
%         hx = hy';
%         Iy = imfilter(double(wsIsub), hy, 'replicate');
%         Ix = imfilter(double(wsIsub), hx, 'replicate');
%         gradmag = sqrt(Ix.^2 + Iy.^2);
% %             figure;imshow(gradmag,[])
%         gradmag(:) = gradmag - min(gradmag(:));
%         gradmag = uint8(gradmag*(256)/(max(gradmag(:))));
% 
%         gradmag_bw = imbinarize(gradmag,graythresh(gradmag));
%             figure;imshow(gradmag_bw,[])
                
%         L = watershed(gradmag_bw);
%         Lrgb = label2rgb(L);
%             figure;imshow(Lrgb,[])
        
        se = strel('disk',3);  
        wsIsub_e = imerode(wsIsub,se);
%             figure;imshow(wsIsub_e,[])
        wsIsub_r = imreconstruct(wsIsub_e,wsIsub);
%             figure;imshow(wsIsub_r,[])              
        wsIsub_rd = imdilate(wsIsub_r, se);
        wsIsub_cr = imreconstruct(imcomplement(wsIsub_rd), imcomplement(wsIsub_r));
        wsIsub_cr = imcomplement(wsIsub_cr);
%             figure;imshow(wsIsub_cr);        

        fgm = imregionalmax(wsIsub_cr);
%             figure;imshow(fgm,[])        
            
        fgm2 = bwmorph(fgm,'close',3);
        fgm2 = imfill(fgm2,'holes');
        fgm2 = bwareaopen(fgm2,4);
%             figure,imshow(fgm2,[])
            
        D = bwdist(fgm2);
%             figure;imshow(D,[])
        DL = watershed(D);
%             figure;imshow(DL,[])

            
%         wsIsub_bw = imbinarize(wsIsub_cr);
%             figure;imshow(~wsIsub_bw)            
                        
%         wsIsub_bw2 = wsIsub_bw;
%         wsIsub_bw2(gradmag_bw) = 0;
%             figure;imshow(~wsIsub_bw2) 


%         D = bwdist(~wsIsub_bw2);
%         D = -D;
%         D(bwulterode(fgm2)) = min(D(:));
%         D(~wsIsub_bw2) = -Inf;
%             figure;imshow(D,[])
%         DL = watershed(D);
%             figure;imshow(DL,[])
%         bgm = DL==0;
%             figure;imshow(bgm,[])
            
%         gradmag2 = imimposemin(gradmag, bgm | fgm2);
%             figure;imshow(gradmag2,[])
% 
%         L = watershed(gradmag2);
%             figure;imshow(L,[])
            
%         Lrgb = label2rgb(L,'jet','k','shuffle');
%             figure;imshow(Lrgb,[]);
%             
%         maskL = double(L).*double(wsIsub_bw2);
%             figure;imshow(maskL,[])
            

%         L = label2rgb(DL,'jet','k','shuffle');
%         figure;imshow(L)
        
%         bgm = zeros(size(DL),'uint8');
%         bgm(DL==0) = 1;
% 
%         gradmag2 = imimposemin(gradmag, bgm | fgm);
%         L = watershed(gradmag2);
% %         Lrgb = label2rgb(L, 'jet', 'w', 'shuffle');
% %         figure,imshow(Lrgb)


% Standard Watershed
%         D = bwdist(~bw);
%         D = -D;
%         D(~bw) = -Inf;
%         DL = watershed(D);


        maskL = double(DL).*double(bw);
        dd = bwconncomp(maskL); %gradmag result connectivity map
        if (dd.NumObjects > 1) %if segmentation finds two or more objects
            ddPL = dd.PixelIdxList; %pass pixelIdxList to new var
            ddPLnew = cell(1); %pre allocate var
            newCount = 0; %object counter
            for oldCount = 1:length(ddPL) %iterate through pixel list of ea. object
                if (length(ddPL{oldCount}) > 40) %if area of "new object(s)" > 40, keep
                    newCount = newCount+1; %increment object counter
                    ddPLnew{1,newCount} = ddPL{oldCount}; %filtered object list                   
                end
            end
            if (newCount>=1)
                dd.PixelIdxList = ddPLnew;
                dd.NumObjects = newCount;
            end
        end
        
        myProps = {'Area', 'BoundingBox', 'Centroid', 'PixelIdxList'}; 
        ddStats = regionprops(dd, myProps);

        for ddcount=1:size(ddStats,1) %modify pixel indexing wrt original image wsI
            tempPixelList = ddStats(ddcount).PixelIdxList; %pixel lists of new objects
            [ddRow,ddCol] = ind2sub(size(maskL),tempPixelList); %using image size maskL
            sizeBB = ddStats(ddcount).BoundingBox; %offset of new object in bounding box info
            ddRow = floor(ddRow+wsBox(2)); %2 offsets. bounding box within bounding box
                ddRow(ddRow>size(wsI,1)) = size(wsI,1); %correct for border pixel getting rounded out of range
            ddCol = floor(ddCol+wsBox(1)); %2 offsets. bounding box within bouding box
                ddCol(ddCol>size(wsI,2)) = size(wsI,2); %correct for border pixel getting rounded our of range
            newPixelList = [];
            for tempPLcount=1:size(tempPixelList,1)
                newPixelList(tempPLcount,1) = sub2ind(size(wsI),ddRow(tempPLcount),ddCol(tempPLcount)); %reference pixels wrt to original image size
            end
            ddStats(ddcount).PixelIdxList = newPixelList; %update pixel list
            ddStats(ddcount).BoundingBox = [sizeBB(1)+wsBox(1), sizeBB(2)+wsBox(2), sizeBB(3), sizeBB(4)]; %update bounding box
            ddCen = ddStats(ddcount).Centroid;
            ddStats(ddcount).Centroid = [ddCen(1)+wsBox(1), ddCen(2)+wsBox(2)]; %update centroid      
        end

        ddStatsCell = struct2cell(ddStats); %current objects' stats converted to cell
        if (j == 1) %case when creating first time
            allddStatsCell = ddStatsCell;
        else %case when concatenating
            allddStatsCell = [allddStatsCell, ddStatsCell]; %build up objects stats
        end

%         L2 = labelmatrix(dd);
% %         figure,imshow(label2rgb(L2,'jet','w','shuffle'));
%         figure('Name',num2str(j),'NumberTitle','off')
%         imshowpair(double(wsIsub),label2rgb(L2,'jet','w','shuffle'),'montage');
% %         set(gcf, 'Position', get(0,'Screensize')); %whole screen
% %         set(gcf, 'Position', [692    39   667   646]); %right side of screen
        
%         uiwait(gcf)
% %         close gcf
    
        hwait.Color = [mod(j,2) 1 mod(j,2)];
        waitbar(j/length(oldStrucStats),hwait)
    end
    delete(hwait)
    %convert newStats cell back to structure
    newFields = {'Area','Centroid','BoundingBox','PixelIdxList'}; %dont know why order is not same as myProps
    newStats = cell2struct(allddStatsCell,newFields,1); %convert to structure
    newSS = newStats;

end

